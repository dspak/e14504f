---
output: 
  pdf_document:
    latex_engine: xelatex
    citation_package: natbib
    keep_tex: true
    fig_caption: true
    # latex_engine: pdflatex
    # template: svm-latex-ms.tex
title: "Taxonomic assignment of endophytic isolate E14504F"
author: Dan Spakowicz
# - name: Nneoma Adaku
#   affiliation: 
# - name: Daniel J Spakowicz
#   affiliation: Program in Computational Biology and Bioinformatics, Yale University, New Haven, CT
# - name: Scott Strobel
#   affiliation: Department of Molecular Biophysics and Biochemistry; Yale University, New Haven, CT
# - name: Faye Rogers
#   affiliation: 
# abstract: ""
# keywords: "asthma, microbiome, RNAseq, metatranscriptomics"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
spacing: double
bibliography: Nneoma.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE)

# Load the required packages
list.of.packages <- c("seqinr", "googlesheets", "tidyverse", "httpuv", "rentrez",
                      "ape", "treebase", "ips", "ggtree", "ggtree", "Biostrings",
                      "msa", "phangorn", "ggrepel")
new.packages <- list.of.packages[!(list.of.packages %in% 
                                     installed.packages()[,"Package"])]

# Install missing packages
if (length(new.packages)) install.packages(new.packages, 
                                           repos = "http://cran.rstudio.com/")
# Load required packages
lapply(list.of.packages, require, character.only = TRUE)

# source("https://bioconductor.org/biocLite.R")
# biocLite("muscle")
# biocLite("ggtree")
# biocLite("msa")

# Set seed
set.seed(12345)
```

# Introduction

This is the script used to build a tree for Nneoma's fungus and assign its taxonomy.

I started by rolling through the databases from the recent review http://jcm.asm.org/content/55/4/1011.full to check if any would be useful for this project.

* BOLD systems http://v4.boldsystems.org/index.php/IDS_OpenIdEngine only have ITS identification.
* Looks like this is a good place for morphological features https://aftol.umn.edu/ and can even make a nexus file to include in the tree -- but aftol has been lost? (goes to godaddy website...)
* BROAD doesn't have an identification portal
* EZBioCloud doesn't have a fungal id section
* FungiDB is just genomics
* UNITE is just ITS
* IndexFungorum doesn't have an id search (but could be useful for morphology)
* CBS can be searched directly for LSU and there are lots of good hits. However, I'd rather find a paper that has gone through the effort of identifying isolates with multiple loci
* SILVA has an LSU search https://www.arb-silva.de/ 
** Identity: 43.61, LCA tax SILVA: None
** SSU Iden: 99.37, LCA tax. SILVA: None
* RDP http://rdp.cme.msu.edu/classifier/ 
  * E14504F-LSU     Root(100%) Fungi(100%) Basidiomycota(100%) Agaricomycetes(100%) Cantharellales(100%) Ceratobasidiaceae(100%) Thanatephorus(100%)

The RDP result is strong, with 100% confidence in the genus Thanatephorus. The CBS searches also found organisms of either Thanatephorus (telomorph) or Rhizoctonia (anamorph). This will very likely be the genus to which E14504F belongs. In addition, Nneoma and I found a few papers that deal with isolates of Rhizoctonia/Thanatephorus:

* [@gonzalez_ribosomal_2001] has a bunch of Thanatephorus isolates with genbank accession numbers for ITS and 28S, but nothing outside the genus (which is necessary to demonstrate the circumscription in this case).
* [@tupac_otero_diversity_2002] just have ITS and have several genera that were isolated from orchids. It's more orchid-centric than fungus-centric.
* [@lopez-chavez_proteomic_2016] defines a Thanatephorus isolate using ITS alone. The tree shows weak node support separating Thanatephorus from Ceratobasidium, but clearly their isolate is closest to a Thana. 
* [@gonzalez_phylogenetic_2016] does a really nice job of creating a multi-locus tree. This should be the model going forward. 

# Methods

I converted the table of genbank accession numbers from [@gonzalez_phylogenetic_2016] to a google spreadsheet. 

Here are the files that Nneoma created using the Staden package (pregap & gap). As soon as these have genbank accession numbers I'll add them to the table so that they can be pulled with the other sequences from the table and remove this code block and the merge code block.

## Version notes
ITS1, RPB2 and TEF1 did not align well with the Gonzalez et al set [-@gonzalez_phylogenetic_2016]. Reverse complement and re-check the alignment. 

## Read in fastas

```{r read fastas as a list of strings}
files <- list.files(path = "~/Dropbox/Rainforest project/E14504F sequences/", 
                    pattern = "*.fasta", full.names = TRUE)
ofastas <- list()
for (f in files) {
  tmp <- readLines(f)
  tmp[2:length(tmp)] <- tolower(tmp[2:length(tmp)])
  ofastas[[f]] <- tmp
}

# Adjust names of list
CleanPaths <- function(names){
  tmp <- gsub(".*E14504F? (.*)\\.fasta", "\\1", names)
  tmp <- gsub(" partial| FULL| ver2", "\\1", tmp)
  return(tmp)
}
names <- CleanPaths(names(ofastas))
names(ofastas) <- names

# Collapse sequences to one line header, one line sequence
CollapseTwoLines <- function(fastaString){
  if (length(fastaString) > 2) {
    x <- fastaString
    y <- x[2:length(x)]
    y <- paste(y, collapse = "")
    z <- c(x[1], y)
    return(z)
  } else {
    return(fastaString)
  }
}
# Iterate function over the list
for (i in names(ofastas)) {
  ofastas[[i]] <- CollapseTwoLines(ofastas[[i]])
}

# Remove any non-ACTGN nucleotides
ofastas <- lapply(ofastas, function(x) gsub("^[^>](.*)[^actgn]", "\\1n", x))


# # Cat ITS1 and ITS2 sep by 100 N's and remove ITS2
# # Removed this step because ITS1 is not aligning to Gonzalez et al even after rev comp
# its <- grep("ITS", names(ofastas))
# ofastas[[its[1]]] <- c(ofastas[[its[1]]], paste(rep("N", 100), collapse = ""), 
#                        ofastas[[its[2]]][2])
# ofastas <- ofastas[-its[2]]
# names(ofastas)[grep("ITS", names(ofastas))] <- "ITS"
```

```{r pull sequences from google sheets and retrieve from Genbank}
# Load table into dataframe
sheet <- gs_title("E14504F")
x <- gs_read(sheet)

# Convert hyphen-only columns to NA
x <- data.frame(apply(x, 2, function(x) gsub("^-$", NA, x)), as.is = TRUE)

# Take in a character vector of genbank accession numbers and return a fasta 
# file in ape format
RetrieveSequencesAsString <- function(charvec){
  try({
    string <- entrez_fetch(db = "nucleotide", id = charvec, rettype = "fasta")
    string <- unlist(strsplit(string, split = "\n"))
    return(string)
  }, silent = TRUE)
}

# Retrieve all sequence into a list
loci <- colnames(x[,6:12])
gfastas <- list()
for (i in loci) {
  gfastas[[i]] <- RetrieveSequencesAsString(x[,grep(i, colnames(x))])
}
# Remove those without any sequences
gfastas <- gfastas[-(which(sapply(gfastas, class) == "try-error"))]

# Convert all to lowercase (needed for nucleotide substitution matrix)
# and remove any nucleotides other than actg or n
seqs <- list()
ConvertToLowercase_actgn <- function(gfastas) {
  seqs <- lapply(gfastas, function(x) grep("^[^>]", x))
  for (i in 1:length(gfastas)) {
    for (j in 1:length(seqs[[i]])) {
      tmp <- tolower(gfastas[[i]][seqs[[i]][j]])
      tmp <- unlist(strsplit(tmp, split = ""))
      notn <- grep("[^actgn]", tmp)
      tmp[notn] <- "n" 
      tmp <- paste(tmp, collapse = "")
      gfastas[[i]][seqs[[i]]][j] <- tmp
    }
  }
  return(gfastas)
}
gfastas <- ConvertToLowercase_actgn(gfastas)
```

```{r change all names}
# Create tip labels
tips <- paste(x$Name, x$Voucher.ID, sep = " ")

# Get names for each of the sequences as list
hasseq <- apply(x[6:12], 2, function(x) !is.na(x))
newlabels <- apply(hasseq, 2, function(x) tips[x])

# Reduce labels set to those in gfastas
newlabels <- newlabels[names(newlabels) %in% names(gfastas)]

# Changes all names in gfastas
for (i in 1:length(gfastas)) {
  temp <- tempfile()
  write(gfastas[[i]], temp)
  tmp2 <- seqinr::read.fasta(file = temp)
  temp <- tempfile()
  seqinr::write.fasta(sequences = tmp2, names = newlabels[[i]], file.out = temp)
  gfastas[[i]] <- readLines(temp)
}
```

```{r reverse complement all sequences}
# Read in each string to ape as a fasta file
grfastas <- list()
for (i in 1:length(gfastas)) {
  temp <- tempfile()
  write(gfastas[[i]], temp)
  grfastas[[i]] <- ape::read.FASTA(file = temp)
}
names(grfastas) <- names(gfastas)

# Reverse complement all sequences
grfastas <- lapply(grfastas, ape::complement)

# Write each to fasta and read back in as string
for (i in names(grfastas)) {
  ape::write.dna(x = grfastas[[i]], temp, format = "fasta")
  grfastas[[i]] <- readLines(temp)
}
```

```{r merge Nneomas e14504f fastas with genbank forward and reverse complements}
# Create a list for "both fastas" and append the genbank string onto Nneoma's
bfastas <- list()
for (n in names(gfastas)){
  if (n %in% names(ofastas)) {
    bfastas[[n]] <- c(ofastas[[which(names(ofastas) %in% n)]], gfastas[[n]])
  } else {
    bfastas[[n]] <- gfastas[[n]]
  }
}

brfastas <- list()
for (n in names(grfastas)){
  if (n %in% names(ofastas)) {
    brfastas[[n]] <- c(ofastas[[which(names(ofastas) %in% n)]], grfastas[[n]])
  } else {
    brfastas[[n]] <- grfastas[[n]]
  }
}
```

## Alignments for distance checking

```{r alignment each locus}
#### ALERT !!!
# This section takes ~ 10 minutes to run
# Set to eval=FALSE by default
# 
# Read in each string as a fasta file
fastas <- list()
for (i in 1:length(bfastas)) {
  temp <- tempfile()
  write(bfastas[[i]], temp)
  fastas[[i]] <- ape::read.FASTA(file = temp)
}

# Align sequences
alns <- lapply(fastas, ape::muscle)
names(alns) <- names(bfastas)

# Read in each string as a fasta file
rfastas <- list()
for (i in 1:length(brfastas)) {
  temp <- tempfile()
  write(brfastas[[i]], temp)
  rfastas[[i]] <- ape::read.FASTA(file = temp)
}

# Align sequences
ralns <- lapply(rfastas, ape::muscle)
```

```{r score the alignments}
# Distance calculation for each alignment
fdist <- lapply(alns, function(x) dist.dna(x, as.matrix = TRUE))
rdist <- lapply(ralns, function(x) dist.dna(x, as.matrix = TRUE))
names(fdist) <- names(rdist) <- names(gfastas)

# Retrieve the E14504F distance (when it's in the sequence)
compdist <- list()
for (i in names(fdist)) {
  # f <- fdist[[i]][,grep("E14504F", colnames(fdist[[i]]))]
  # r <- rdist[[i]][,grep("E14504F", colnames(rdist[[i]]))]
  f <- fdist[[i]][,1]
  r <- rdist[[i]][,1]
  f <- data.frame(taxon = rownames(fdist[[i]]), forward = f)
  r <- data.frame(taxon = rownames(rdist[[i]]), revcomp = r)
  compdist[[i]] <- full_join(f, r, by = "taxon")
}

# Plot the results for each alignment
for (i in names(compdist)) {
  # Melt each element of the list
  toplot <- compdist[[i]] %>%
    gather(key = "direction", value = "distance" , -taxon)
  # Plot
  ggplot(toplot, aes(x = taxon, y = distance)) +
    geom_point(aes(color = direction)) +
    labs(x = "Taxon", y = "Distance",
         title = paste("Forward vs Rev Comp alignments to E14504F: ", i, 
                       sep = "")) +
    theme(axis.text.x = element_blank())
    ggsave(paste("indiv_alignments/directionComp_", i, ".pdf", sep = ""), 
           height = 4, width = 8)
}
```

```{r retrieve the optimal direction for each sequence}

```

Of the regions checked, only TEF1 contained sequences that had reverse complements. I'll make a tree of just LSU and RPB2. Given the variability observed in the RPB2 region, I expect this will sufficiently resolve the tree.

Update: indeed the resolution was good, but the closest match was to Sclerotium hydrophilium, which does not contain RPB2 and in many cases does not have LSU. All of the Sclerotium in our table contain ITS, though, so I'll make sure to include that region.

```{r subset to regions of interest}
# Input regions of interest
roi <- c("LSU", "RPB2", "ITS")
roi <- names(alns) %in% roi

# subset alignment
alns <- alns[roi]
```

```{r terminal gaps as n}
# Not sure this is necessary, clustalw doesn't penalize terminal gaps but I 
# can't find if muscle does
```


```{r remove gaps}
# Remove gaps present in 30% of the columns
rmgaps <- lapply(alns, function(x) del.colgapsonly(x, threshold = 0.3))
names(rmgaps) <- names(alns)
# Write alignments to files for visualization in Jalview
for (i in names(rmgaps)) {
  ape::write.dna(rmgaps[[i]], format = "fasta", file = paste("indiv_alignments/combined_", i, ".afa", sep = ""))
}
```

```{r visualize alignments, message=FALSE}
lapply(rmgaps, function(x) image.DNAbin(x, show.labels = FALSE))
```

I can't figure out how to add titles in `image.DNAbin()`, but the order is "ITS"  "LSU"  "RPB2" "TEF1" "ATP6". The ITS looks to have a few orgs that might be revcomps, maybe three. I'm not sure how best to identify those and replace them in this format. It looks like the N length is short by ~ 20nt.

```{r substitution models}
# Get alignment into class pml or phyDat as list inphydat
inphydat <- list()
for (i in names(rmgaps)) {
  temp <- tempfile()
  ape::write.dna(rmgaps[[i]], format = "fasta", file = temp)
  inphydat[[i]] <- phangorn::read.phyDat(temp, format = "fasta")
}

# Check all substitution models for each region
tests <- lapply(inphydat, function(x) phangorn::modelTest(x, model = "all"))

# Retrieve the best models
bestmodel <- sapply(tests, function(x) x$Model[which.max(x$logLik)])
names(bestmodel) <- names(rmgaps)
```

The best model for both LSU and RPB2 is GTR+G, therefore I don't have to partition the interleaved dataset.

```{r individual locus trees, eval=FALSE}
tophydat <- lapply(rmgaps, phyDat)
onetree <- lapply(tophydat, dist.ml)
ot <- lapply(onetree, NJ)
ot.ml <- list()
for (i in names(ot)) {
    ot.ml[[i]] <- pml(ot[[i]], tophydat[[i]])
}
optim.ml <- list()
for (i in names(ot)) {
    optim.ml[[i]] <- optim.pml(ot.ml[[i]], model = "GTR", rearrangement = "stochastic")
}
bs <- list()
for (i in names(ot)){
  bs[[i]] <- bootstrap.pml(optim.ml[[i]], bs=100, optNni=TRUE, multicore=TRUE, control = pml.control(trace=0))
}
trees <- list()
for (i in names(ot)) {
  trees[[i]] <- plotBS(optim.ml[[i]]$tree, bs[[i]], p = 20, type = "p")
}
for (i in names(trees)) {
  df <- as.data.frame(trees[[i]])
  ggtree(df) +
    geom_tiplab(size=3) +
    geom_text2(aes(subset = !isTip, label = label), size = 3, hjust = 1.1, vjust = -0.5) +
    labs(title = paste("E14505F single locus tree: ", i, sep = "")) +
    xlim(0, max(df$x, na.rm = TRUE) + (max(df$x, na.rm = TRUE)*0.3)) +
    ggsave(paste("singleLocusTree_", i, ".pdf", sep = ""), height = 11, width = 8.0)
}
```

```{r interleaving}
# Get all names in all alignments
intnames <- unique(unlist(sapply(rmgaps, rownames)))

# Add a sequence of N's for taxa without that locus
allns <- list()
for (i in names(rmgaps)) {
  # Grab all names NOT in the alignment
  tmp_names <- intnames[!(intnames %in% rownames(rmgaps[[i]]))]
  # Create a list of N's for each name equal to alignment length
  tmp_seqs <-  vector(mode = "list", length = length(tmp_names))
  for (j in 1:length(tmp_seqs)) {
    tmp_seqs[[j]] <- rep("n", ncol(rmgaps[[i]]))
  }
  # Convert to DNAbin
  tmp_seqs <- ape::as.DNAbin(tmp_seqs)
  # Convert to muscle alignment matrix
  tmp_seqs <- ape::muscle(tmp_seqs)
  rownames(tmp_seqs) <- tmp_names
  # Bind to N sequences to that alignment
  allns[[i]] <- rbind(rmgaps[[i]], tmp_seqs)
}

# Bind all of the alignments into one
interleaved <- do.call("cbind", allns)
```

```{r combined tree, eval=FALSE}
# Adjust names
rownames(interleaved) <- make.names(rownames(interleaved))

# Create nexus output for mrbayes with GTR+G substitution mode
mrbayes(interleaved, "all.nex", nst = 6, rates = "invgamma")

# Create phylip output for raxml
write.phy(interleaved, "all.phy")

# Write Mr Bayes submission file to move to Grace and run there.
fileConn <- file("mrbayes_e14504f_all.sh")
writeLines(c("#!/bin/bash", 
             "#SBATCH --ntasks=4 --nodes=1",
             "#SBATCH --time=12:00:00",
             "#SBATCH --job-name=mrbayes_e14504f",
             "#SBATCH --mail-user=daniel.spakowicz@yale.edu",
             "#SBATCH --mail-type=ALL",
             "",
             "# Produced by DS_tree.Rmd",
             "# Dan Spakowicz",
             paste("# ", Sys.time(), sep = ""),
             "# Submission file for the MrBayes analysis of the E14504F tree using the sequencing in the google sheet 'E14504F'",
             "",
             "cd /project/fas/gerstein/djs88/e14504f",
             "module load Apps/MrBayes/3.2.2",
             "mpirun mb all.nex"), fileConn)
close(fileConn)

# Create a new file for RAxML (find the largest existing file and add one)
ls <- list.files(pattern = ".*all_\\d+")
maxiter <- max(as.numeric(gsub(".*all_(\\d+)", "\\1", ls)))

# Call RAxML (takes ~20 min)
system({
  paste("raxmlHPC-AVX -s all.phy -m GTRGAMMA -n all_", maxiter+1, " -f a -# 100 -x 12345 -p 12345", sep = "")
})
system({
  paste("raxmlHPC-AVX -m GTRGAMMA -J MRE -z RAxML_bootstrap.all_", maxiter+1, " -n tre", sep = "")
})
```

```{r final tree}
raxml <- read.raxml(paste("RAxML_bipartitionsBranchLabels.all_", maxiter+1, sep = ""))
ggtree(raxml) +
    geom_tiplab(size=3) +
    geom_text2(aes(label=bootstrap), size = 3, hjust = 1.1, vjust = -0.5) +
    # geom_text2(aes(subset = !isTip, label = label), size = 3, hjust = 1.1, vjust = -0.5) +
    # labs(title = paste("E14505F single locus tree: ", i, sep = "")) +
    xlim(0, 1.2) +
    ggsave("all_interleaved.pdf", height = 11, width = 8.0)
  # geom_label_repel(aes(label=bootstrap, fill=bootstrap))
```


## Alternative methods

* retreive Treebase file and add E14504F sequences to those alignments
** This is becoming increasingly attractive given the seemingly large fraction of reverse complements observed. Particularly now that the ITS1 and ITS2 sequences are available, all sections except atp6 would be usable. It's worth taking the time to explore how to add one more sequence onto an existing alignment in R.

However, upon completing this it appears the sequenced regions of ITS1, RPB2 and TEF1 are quite (and quite surprisingly) distinct. This includes checking alignments with both directions of those sequences (forward and reverse complements). Strangely, The RPB2 alignment looks fine when done with just that locus, though about half of the sequences look to be reverse complemented. Looks like we may have to go back to the drawing board (which is above, and possibly with new sequences).

```{r treebase, eval=FALSE}
# Retrieve Gonzalez study
# Retd from https://treebase.org/treebase-web/search/study/matrices.html?id=15006 on 12 May 2017
nexlines <- readLines("1_1489744745_5LOCI_Cantharelloid_Ceratobasidiaceae.nexorg")

ConvertNexusToAln <- function(nexlines){
  start <- grep("MATRIX", nexlines)+1
  end <- min(grep("END;", nexlines[start:length(nexlines)], fixed = TRUE))
  aln <- nexlines[start : ((start + end)-3)]
  aln <- gsub("^\t", ">", aln)
  aln <- unlist(strsplit(aln, split = " {2,}"))
  aln <- gsub(" ", "_", aln)
  aln <- gsub("'", "", aln)
  return(aln)
}
aln <- ConvertNexusToAln(nexlines)

# Write alignment to file
writeLines(aln, "gonzalez_phylogenetic_2016.afa")

# Concatenate E14504F fastas for alignment
# order is partition Names = 4 : ITSLSU , RPB2 , EF1a , ATP6;
SingleFasta <- function(ofasta){
  e145 <- c(ofastas[["ITS"]], ofastas[["LSU"]], 
            ofastas[["RPB2"]], ofastas[["TEF1"]])
  e145 <- e145[-grep(">", e145)]
  e145 <- c(">E14504F", e145)
  return(e145)
}
e145 <- SingleFasta(ofastas)
writeLines(e145, "e14504f_gonzalez_allloci.fa")

its2_lsu_Ns <- function(ofastas) {
  e145 <- c(paste(rep("N", nchar(ofastas[["ITS1"]][2])), collapse = ""),
            paste(rep("N", 100), collapse = ""),
            ofastas[["ITS2"]], 
            paste(rep("N", 100), collapse = ""),
            ofastas[["LSU"]], 
            paste(rep("N", nchar(ofastas[["RPB2"]][2])), collapse = ""),
            paste(rep("N", nchar(ofastas[["TEF1"]][2])), collapse = ""))
  e145 <- e145[-grep(">", e145)]
  e145 <- c(">E14504F", e145)
  return(e145)
}
e145_itslsu <- its2_lsu_Ns(ofastas)
writeLines(e145_itslsu, "e14504f_gonzalez_itslsu.fa")
```

```{r align to alignment with muscle}
# System call for muscle (arg isn't available in the R version yet)
system({
  "muscle -profile -in1 gonzalez_phylogenetic_2016.afa -in2 e14504f_gonzalez_allloci.fa -out combined.afa"
})
system({
  "muscle -profile -in1 gonzalez_phylogenetic_2016.afa -in2 e14504f_gonzalez_itslsu.fa -out combined.afa"
})

# This step adds ~1k characters onto the alignment... not sure what it's 
# doing and the documentation is terrible
# system({
#   "muscle -in combined.afa -out refined.afa -refine"
# })

# Convert to nexus
newaln <- read.fasta("combined.afa")
write.nexus.data(newaln, "combined.nex", interleaved = FALSE)

# Append a mr bayes block at the end of the nexus file
x <- read.nex("combined.nex")
mrbayes(x, "combined_bayes.nex")

# Write phylip file for raxml tree
write.phy(x, "combined_raxml.phy")
# Read in phy file to file "y" in sequence 4
y <- readLines("combined_raxml.phy")
y <- gsub("y", "n", y)
# Re-write phy file
writeLines(y, "combined_raxml.phy")
```

```{r subset gonzalex el al alignment to its2 and lsu}
# Read in fasta file
x <- seqinr::read.fasta("combined.afa")
# Subset to aligned coordinates
# Found these coordinates by visualizing with Jalview, looking for where E14504F 
# matches the other alignments
y <- lapply(x, function(x) x[286:1343])
# Write output to file to bring into ape for gap cleaning
seqinr::write.fasta(sequences = y, names = names(y), nbchar = 80, 
                    file.out = "combined_its2lsu.fa")

# Read into ape for gap cleaning
y <- seqinr::read.alignment("combined_its2lsu.fa", format = "fasta")
# Remove gaps
y <- ape::del.colgapsonly(y, threshold = 0.3)
# Write output
y <- ape::write.dna(y, format = "fasta", file = "combined_its2lsu.fa")

# Write input files for bayes and raxml
# Read into ips
x <- ips::read.fas(x = "combined_its2lsu.fa")
# Append a mr bayes block at the end of the nexus file
ips::mrbayes(x, "combined_bayes_its2lsu.nex")

# Write phylip file for raxml tree
ips::write.phy(x, "combined_raxml_its2lsu.phy")
```

```{r RAxML, eval=FALSE}
# Call RAxML (takes ~20 min)
system({
  "raxmlHPC-AVX -s combined_raxml.phy -m GTRGAMMA -n comb_1 -p 12345 -x 12345 -# 100"
})
system({
  "raxmlHPC-AVX -m GTRGAMMA -J MRE -z RAxML_bootstrap.comb_1 -n tre"
})

```

```{r bayes submission file}
# Write Mr Bayes submission file to move to Grace and run there.
fileConn <- file("mrbayes_e14504f_gonzalez.sh")
writeLines(c("#!/bin/bash", 
             "#SBATCH --ntasks=10 --nodes=1",
             "#SBATCH --time=12:00:00",
             "#SBATCH --job-name=mrbayes_e14504f",
             "#SBATCH --mail-user=daniel.spakowicz@yale.edu",
             "#SBATCH --mail-type=ALL",
             "",
             "# Produced by DS_tree.Rmd",
             "# Dan Spakowicz",
             "# 14 May 2017",
             "# Submission file for the MrBayes analysis of the E14504F tree, using [@gonzalez_phylogenetic_2016] alignment as a reference",
             "",
             "cd /project/fas/gerstein/djs88/e14504f",
             "module load Apps/MrBayes/3.2.2",
             "mpirun mb combined_bayes.nex"), fileConn)
close(fileConn)

# Causes a public key error -- have to copy into terminal
# system({
#   "scp /Users/danielspakowicz/Dropbox/Rainforest\ project/tree/combined_bayes.nex djs88@grace-next.hpc.yale.edu:/project/fas/gerstein/djs88/e14504f/"
# })
# system({
#   "scp /Users/danielspakowicz/Dropbox/Rainforest\ project/tree/mrbayes_e14504f_gonzalez.sh djs88@grace-next.hpc.yale.edu:/gpfs/home/fas/gerstein/djs88/myscripts/projects/e14504f/"
# })

```

```{r, eval=FALSE}
# WARNING : This step takes ~5 hours. Set to eval=FALSE by default
# system({
#   "mb combined_bayes.nex"
# })
```

```{r tree visualization}
z <- read.tree("~/Documents/projects_notbackedup/e14504f/RAxML_MajorityRuleExtendedConsensusTree.tre")
ggplot(z) +
  ggtree::geom_tree(layout = "circular") +
  ggtree::geom_tiplab(size = 2)

z <- read.tree("~/Documents/projects_notbackedup/e14504f/RAxML_MajorityRuleConsensusTree.tre2")
ggplot(z) +
  ggtree::geom_tree(layout = "circular") +
  ggtree::geom_tiplab(size = 2)

z <- read.tree("~/Documents/projects_notbackedup/e14504f/RAxML_StrictConsensusTree.tre3")
ggplot(z) +
  ggtree::geom_tree(layout = "circular") +
  ggtree::geom_tiplab(size = 2)

z <- read.tree("~/Documents/projects_notbackedup/e14504f/RAxML_MajorityRuleExtendedConsensusTree.tre4")
ggplot(z) +
  ggtree::geom_tree(layout = "circular") +
  ggtree::geom_tiplab(size = 2)

z <- read.tree("~/Documents/projects_notbackedup/e14504f/combined_bayes_its2lsu.nex.con.tre")
ggplot(z) +
  ggtree::geom_tree(layout = "circular") +
  ggtree::geom_tiplab(size = 2)
```


After a few segmentation faults I decided to push this to grace to run there, and just have it write the slurm submission and scp the files from this script. 

## Morphological analysis
https://aftol.umn.edu/species/Thanatephorus_cucumeris 

Look for uniperforate septa with swollen margin 

Have to distinguish it from other members of Ceratobasidaceae, namely https://aftol.umn.edu/species/Ceratobasidium_cornigerum

Oh damn they're very similar. Looks like the difference is determined by electron microscopy, in the substructure of the pore cap. Namely, Ceratobasidium has a cap with uniform electron-dense contents and Thanatephorus has a cap with three internal layers (central electron-dense layer between two less electron dense layers). Well that's not super helpful. 

Directly copied from wikipedia
>> R. solani does not produce spores, hence is identified only from mycelial characteristics or DNA analysis. Its hyphal cells are multinucleated. It produces white to deep brown mycelium when grown on an artificial medium. The hyphae are 4–15 μm wide and tend to branch at right angles. A septum near each hyphal branch and a slight constriction at the branch are diagnostic. R. solani is subdivided into anastomosis groups based on hyphal fusion between compatible strains.[12][13] 

The teleomorph of R. solani is Thanatephorus cucumeris. It forms club-shaped basidia with four apical sterigmata on which oval, hyaline basidiospores are borne.

Nice pictures here http://www.apsnet.org/edcenter/intropp/lessons/fungi/Basidiomycetes/Pages/Rhizoctonia.aspx
"Rhizoctonia species can be divided into two groups based on the number of nuclei present in cells of the hyphae. This characteristic can be assessed by staining hyphae with a fluorescent dye that binds specifically to the DNA in the nucleus. Binucleate Rhizoctonia species have two nuclei in each cell (Figure 23). Rhizoctonia cerealis is the only binucleate species that causes turfgrass disease. Multinucleate species have three or more nuclei in each cell (Figure 24). Rhizoctonia solani, R. zeae, and R. oryzae are multinucleate species."

"Rhizoctonia solani forms colonies on potato dextrose agar (PDA) that range in color from buff to black (Figure 25). Sclerotia are produced on the surface of cultures after 4 to 6 weeks, and are irregularly shaped, light tan to black, and usually >1 mm (0.04 in.) in width (Figure 26). The optimum temperature for growth of R. solani in pure culture ranges from 18ºC (64.4ºF) to 28ºC (82.4ºF). This species is divided into 11 AGs. Isolates in AGs 1 and 2 are commonly associated with turfgrass disease."



# Results and Discussion

# References
